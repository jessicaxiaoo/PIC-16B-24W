[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "posts/hw1/index.html",
    "href": "posts/hw1/index.html",
    "title": "HW1",
    "section": "",
    "text": "First, we will create a database with three tables: temperatures, stations, and countries. Lets import the necessary libraries.\nimport sqlite3\nimport pandas as pd\nimport numpy as np\nNow, we will read the temperatures data from a .csv file. Because this file is large, we read it into the database in chunks of 100000 rows. We will use the prepare_df function to clean up the data chunks as we read it in.\nconn = sqlite3.connect(\"hw1.db\") #open database connection\n\ntemps_iter = pd.read_csv(\"temps.csv\", chunksize = 100000)\ndef prepare_df(df):\n    df = df.set_index(keys=[\"ID\", \"Year\"])\n    df = df.stack()\n    df = df.reset_index()\n    df = df.rename(columns = {\"level_2\"  : \"Month\" , 0 : \"Temp\"})\n    df[\"Month\"] = df[\"Month\"].str[5:].astype(int)\n    df[\"Temp\"]  = df[\"Temp\"] / 100\n    return(df)\nfor temps in temps_iter:\n    temps = prepare_df(temps)\n    temps.to_sql(\"temperatures\", conn, if_exists = \"append\", index = False)\ntemps.head()\nLet’s read the data for countries and stations next.\ncountries = pd.read_csv('country-names.csv')\ncountries = countries.rename(columns= {\"FIPS 10-4\": \"FIPS_10-4\", \"ISO 3166\": \"ISO_3166\"})\ncountries.head()\nurl = \"https://raw.githubusercontent.com/PhilChodrow/PIC16B/master/datasets/noaa-ghcn/station-metadata.csv\"\nstations = pd.read_csv(url)\nstations[\"FIPS_10-4\"] = stations[\"ID\"].str[0:2]\nstations.head()\ncountries.to_sql(\"countries\", conn, if_exists=\"replace\", index=False)\nstations.to_sql(\"stations\", conn, if_exists=\"replace\", index=False)\n\n\n\nWe can write a function that uses a SQL command to extract a Pandas dataframe from our database. We use the LEFT JOIN keyword to merge the three tables, and the WHERE to specify the conditions (a country, two integers that give the earliest and latest years, and a specific month).\ndef query_climate_database(db_file, country, year_begin, year_end, month):\n    \n    conn = sqlite3.connect(db_file)\n\n    cmd = f\"\"\"\n    SELECT S.name, S.latitude, S.longitude, C.name, T.year, T.month, T.temp\n    FROM temperatures T\n    LEFT JOIN stations S ON T.id = S.id\n    LEFT JOIN countries C on SUBSTRING (T.id, 1, 2) = C.'FIPS 10-4'\n    WHERE C.name = ? AND T.year &gt;= {year_begin} AND T.year &lt;= {year_end} AND T.month = {month}\n    \n    \"\"\"\n    \n    df = pd.read_sql_query(cmd, conn, params=(country,))\n    conn.close()\n\n    df = df.rename(columns={'Name': 'Country'})\n\n    return df\n\nHere’s an example of using the function query_climate_database to query temperature data in India for August from 1980-2020.\n```python\nquery_climate_database(db_file = \"hw1.db\",\n                       country = \"India\", \n                       year_begin = 1980, \n                       year_end = 2020,\n                       month = 1)\n\n\n\noutput\n\n\n\n\n\n\n\nThis visualization answers the question: How does the average yearly change in temperature vary within a given country?\nWe will first import the packages necessary to achieve this. sklearn is used for linear regression, datetime converts numbers to their corresponding month names, and plotly is used to create the interactive visualizations.\nfrom sklearn.linear_model import LinearRegression\nimport datetime\nfrom plotly import express as px\nNow, we can define a function to perform a linear regression of the temperature on the year, and return the coefficients.\ndef coef(data_group):\n    '''\n    Inputs: dataframe\n    Returns: slope of linear model, representing the average yearly change in temperature\n    '''\n    x = data_group[[\"Year\"]]\n    y = data_group[\"Temp\"]\n    LR = LinearRegression()\n    LR.fit(x, y)\n    return LR.coef_[0]\nThe function temperature_coefficient_plot queries the specified data and produces a geographic scatterplot. The location of each point is the location of the station and the color is based on the estimate of yearly change in temperature at the station in the given time interval.\ndef temperature_coefficient_plot(country, year_begin, year_end, month, min_obs, **kwargs):\n    '''\n    Inputs: a country, a bounded time interval, a month, minimum data points to be considered, and optional\n    plotting arguments\n    Returns: a geographic plot indicating the changes in temperature over time\n    '''\n    #obtain and clean the data\n    df = query_climate_database(db_file = \"hw1.db\", country = country, year_begin = year_begin, year_end = year_end, month = month) #read in the data using previously defined function\n    counts = df.groupby([\"NAME\", \"Month\"])[\"Year\"].transform(len)\n    df = df[counts &gt;= min_obs]\n    coefs = df.groupby([\"NAME\", \"Month\", \"LATITUDE\", \"LONGITUDE\"]).apply(coef) #find the estimated yearly change in temperature for each station\n    coefs = coefs.round(3) # round data to 3 decimal places\n    coefs = coefs.reset_index()\n    coefs = coefs.rename(columns = {0 : \"Estimated Yearly Change (C)\"})\n\n    #create the plot\n    title = \"Estimates of Yearly Increase in Temperature in {a} for stations in {b}, years {c} - {d}\"\\\n    .format(a=datetime.date(2021, month, 1).strftime('%B'), b=country, c=year_begin, d=year_end)\n    fig = px.scatter_mapbox(coefs,\n                            lat = \"LATITUDE\",\n                            lon = \"LONGITUDE\",\n                            hover_name = \"NAME\",\n                            color = \"Estimated Yearly Change (C)\",\n                            title = title,\n                            **kwargs)\n    return fig\nHere is an example of using the temperature_coefficient_plot function to visualize the estimated change in temperature across stations in India in January from 1980 to 2020.\ncolor_map = px.colors.diverging.RdGy_r \n\nfig = temperature_coefficient_plot(country = \"India\", year_begin = 1980, year_end = 2020, month = 1, \n                                   min_obs = 10,\n                                   zoom = 2,\n                                   mapbox_style=\"carto-positron\",\n                                   color_continuous_scale=color_map)\nfig.show()\n\n\n\noutput\n\n\n\n\n\nThe visualization I chose answers the question: How is the mean temperature per year changing in comparison to the overall mean temperature?\nThe function diff_from_mean_temp function takes in the same arguments as the query_climate_database: country, year_begin, year_end, and month. With the returned dataframe, it takes the mean temperature over the entire time period and then finds the difference between the mean temperature of each year and the overall mean temperature.\ndef diff_from_mean_temp(country, year_begin, year_end, month, **kwargs):\n    '''\n    Input: a country, a bounded time interval, and a month\n    Returns: a barplot comparing the yearly temperature to the average temperature over the interval\n    '''\n    df = query_climate_database(\"hw1.db\", country, year_begin, year_end, month) \n    mean = np.mean(df[\"Temp\"]) #overall mean temperature of the time interval\n    df = df.groupby([\"Year\"])[\"Temp\"].aggregate(np.mean) #find mean temperature per year\n    df = df.reset_index()\n    df[\"Difference (C)\"] = df[\"Temp\"] - mean #compare mean temperature of year to mean temperature over entire time interval\n    df= df.round(3) #round to 3 decimal places\n    df[\"col\"] = np.where(df[\"Difference (C)\"]&gt;=0, 'red', 'blue')\n\n    #create the plot\n    title = \"Difference in Mean Temperature in {a} for stations in {b} from {c} to {d}\"\\\n    .format(a=datetime.date(2021, month, 1).strftime('%B'), b=country, c=year_begin, d=year_end)\n    fig = px.bar(df, x = \"Year\", y = \"Difference (C)\",\n                hover_data = [\"Year\", \"Difference (C)\"], title = title, color = \"col\", **kwargs)\n    fig.update_layout(showlegend=False) \n    return fig\nHere is an example of using the diff_from_mean_temp function to visualize the difference in mean temperature in China in March from 1980 to 2020.\nfig = diff_from_mean_temp(\"China\", 1980, 2020, 3)\nfig.show()\n Here, the positive red bars indicate that the temperature readings that year were above the mean, and negative blue bars indicate that temperature readings that year were below the mean.\n\n\n\nThe visualization I chose answers the question: How is does temperature vary within regions of a country in a given year?\nThe function query_country_year extracts the relevant data, and the output is passed to year_diff to calculate the difference between the average temperature in the warmest month and the coldest month, at the station level.\ndef query_country_year(db_file, country, year):\n    '''\n    Returns: a dataframe of all temperatures in a country in a single year\n    '''\n    conn = sqlite3.connect(db_file)\n    #cursor = conn.cursor()\n    cmd = f\"\"\"\n    SELECT S.name, S.latitude, S.longitude, C.name, T.year, T.month, T.temp\n    FROM temperatures T\n    LEFT JOIN stations S ON T.id = S.id\n    LEFT JOIN countries C ON C.'FIPS_10-4' = S.'FIPS_10-4'\n    WHERE T.year = {year} AND C.Name = '{country}'\n    \"\"\"\n    \n    df = pd.read_sql_query(cmd, conn)\n    return df\ndef year_diff(df):\n    '''\n    Computes temperature difference between warmest and coldest month\n    '''\n    df_group = df.groupby([\"NAME\"])\n    obs_filter = df_group.count()[\"Name\"]&gt;=12\n    temp_diff = (df_group.max()[['Temp']] - df_group.min()[['Temp']])[obs_filter]\n    coords = df.groupby([\"NAME\"]).first()[[\"LATITUDE\",\"LONGITUDE\"]][obs_filter]\n    x = pd.merge(temp_diff,coords,on='NAME')\n    x = x.rename(columns={'Temp':\"Temperature difference\"})\n    x = x.reset_index()\n    return x\nThe function seasonal_difference_plot takes in a country and a year, and creates a scatterplot of the difference in temperature between the warmest and coolest month of that year.\ndef seasonal_difference_plot(country, year,**kwargs):\n    x = year_diff(query_country_year(\"hw1.db\", country, year))\n    title = f\"Difference in temperature between warmest and coolest month in {year} for stations in {country}\"\n    fig = px.scatter_mapbox(x,\n                            lat = \"LATITUDE\",\n                            lon = \"LONGITUDE\",\n                            hover_name = \"NAME\",\n                            color = \"Temperature difference\",\n                            hover_data={\n                                \"LATITUDE\":':.3f',\n                                \"LONGITUDE\":':.3f',\n                                \"Temperature difference\":':.3f'\n                            },\n                            title = title,\n                            color_continuous_scale=color_map,\n                            **kwargs)\n\n    return fig\nAn example can be seen with Mexico in the year 2020.\nfig = seasonal_difference_plot('Mexico', 2020,\n                               mapbox_style=\"carto-positron\",\n                               zoom=1)\npio.write_image(fig, \"seasonal-diff-barplot.png\")\nfig.show()\n\n\n\noutput\n\n\n\n\n\nThe last visualization I chose answers the question: How does temperature vary across months in a given country? The function query_year_range extracts the relevant data and creates a pandas dataframe from our database. We use the LEFT JOIN keyword to merge the three tables, and the WHERE to specify the conditions (a country and two integers that give the earliest and latest years).\ndef query_country_year_range(db_file, country, year_begin, year_end):\n    '''\n    returns dataframe of all temperatures in a country in a single year.\n    '''\n    conn = sqlite3.connect(db_file)\n    \n    cmd = f\"\"\"\n    SELECT S.name, S.latitude, S.longitude, C.name, T.year, T.month, T.temp\n    FROM temperatures T\n    LEFT JOIN stations S ON T.id = S.id\n    LEFT JOIN countries C ON C.'FIPS 10-4' = S.'FIPS 10-4'\n    WHERE C.name = ? AND T.year &gt;= {year_begin} AND T.year &lt;= {year_end}\n    \"\"\"\n    \n    df = pd.read_sql_query(cmd, conn, params=(country,))\n    return df\nThe function facet_hist takes in a country and two integers for years, and creates a faceted histogram of the temperatures for each month.\ndef facet_hist(country, year_begin, year_end, **kwargs):\n    '''\n    Inputs:\n    '''\n    df = query_country_year_range(\"hw1.db\", country, year_begin, year_end) \n    df.sort_values([\"Year\", \"Month\", \"Temp\"], inplace = True)\n    \n    title = f\"Distribution of Monthly Temperature in {country} between {year_begin} and {year_end}\"\n    fig = px.histogram(df,\n                       x = \"Temp\", \n                       color = \"Year\",\n                       opacity = 0.8, \n                       nbins = 20,\n                       barmode='group',\n                       histnorm = 'percent',\n                       width = 900,\n                       height = 1500,\n                       facet_col = 'Month',\n                       facet_col_wrap = 3, \n                       title = title,\n                        **kwargs)\n    return fig\nAn example can be seen with Canada in the 2018-2020.\nfig = facet_hist(\"Canada\", 2018, 2020)\nfig.show()\n\n\n\noutput"
  },
  {
    "objectID": "posts/hw1/index.html#create-a-database",
    "href": "posts/hw1/index.html#create-a-database",
    "title": "HW1",
    "section": "",
    "text": "First, we will create a database with three tables: temperatures, stations, and countries. Lets import the necessary libraries.\nimport sqlite3\nimport pandas as pd\nimport numpy as np\nNow, we will read the temperatures data from a .csv file. Because this file is large, we read it into the database in chunks of 100000 rows. We will use the prepare_df function to clean up the data chunks as we read it in.\nconn = sqlite3.connect(\"hw1.db\") #open database connection\n\ntemps_iter = pd.read_csv(\"temps.csv\", chunksize = 100000)\ndef prepare_df(df):\n    df = df.set_index(keys=[\"ID\", \"Year\"])\n    df = df.stack()\n    df = df.reset_index()\n    df = df.rename(columns = {\"level_2\"  : \"Month\" , 0 : \"Temp\"})\n    df[\"Month\"] = df[\"Month\"].str[5:].astype(int)\n    df[\"Temp\"]  = df[\"Temp\"] / 100\n    return(df)\nfor temps in temps_iter:\n    temps = prepare_df(temps)\n    temps.to_sql(\"temperatures\", conn, if_exists = \"append\", index = False)\ntemps.head()\nLet’s read the data for countries and stations next.\ncountries = pd.read_csv('country-names.csv')\ncountries = countries.rename(columns= {\"FIPS 10-4\": \"FIPS_10-4\", \"ISO 3166\": \"ISO_3166\"})\ncountries.head()\nurl = \"https://raw.githubusercontent.com/PhilChodrow/PIC16B/master/datasets/noaa-ghcn/station-metadata.csv\"\nstations = pd.read_csv(url)\nstations[\"FIPS_10-4\"] = stations[\"ID\"].str[0:2]\nstations.head()\ncountries.to_sql(\"countries\", conn, if_exists=\"replace\", index=False)\nstations.to_sql(\"stations\", conn, if_exists=\"replace\", index=False)"
  },
  {
    "objectID": "posts/hw1/index.html#query-the-database",
    "href": "posts/hw1/index.html#query-the-database",
    "title": "HW1",
    "section": "",
    "text": "We can write a function that uses a SQL command to extract a Pandas dataframe from our database. We use the LEFT JOIN keyword to merge the three tables, and the WHERE to specify the conditions (a country, two integers that give the earliest and latest years, and a specific month).\ndef query_climate_database(db_file, country, year_begin, year_end, month):\n    \n    conn = sqlite3.connect(db_file)\n\n    cmd = f\"\"\"\n    SELECT S.name, S.latitude, S.longitude, C.name, T.year, T.month, T.temp\n    FROM temperatures T\n    LEFT JOIN stations S ON T.id = S.id\n    LEFT JOIN countries C on SUBSTRING (T.id, 1, 2) = C.'FIPS 10-4'\n    WHERE C.name = ? AND T.year &gt;= {year_begin} AND T.year &lt;= {year_end} AND T.month = {month}\n    \n    \"\"\"\n    \n    df = pd.read_sql_query(cmd, conn, params=(country,))\n    conn.close()\n\n    df = df.rename(columns={'Name': 'Country'})\n\n    return df\n\nHere’s an example of using the function query_climate_database to query temperature data in India for August from 1980-2020.\n```python\nquery_climate_database(db_file = \"hw1.db\",\n                       country = \"India\", \n                       year_begin = 1980, \n                       year_end = 2020,\n                       month = 1)\n\n\n\noutput"
  },
  {
    "objectID": "posts/hw1/index.html#creating-interactive-visualizations",
    "href": "posts/hw1/index.html#creating-interactive-visualizations",
    "title": "HW1",
    "section": "",
    "text": "This visualization answers the question: How does the average yearly change in temperature vary within a given country?\nWe will first import the packages necessary to achieve this. sklearn is used for linear regression, datetime converts numbers to their corresponding month names, and plotly is used to create the interactive visualizations.\nfrom sklearn.linear_model import LinearRegression\nimport datetime\nfrom plotly import express as px\nNow, we can define a function to perform a linear regression of the temperature on the year, and return the coefficients.\ndef coef(data_group):\n    '''\n    Inputs: dataframe\n    Returns: slope of linear model, representing the average yearly change in temperature\n    '''\n    x = data_group[[\"Year\"]]\n    y = data_group[\"Temp\"]\n    LR = LinearRegression()\n    LR.fit(x, y)\n    return LR.coef_[0]\nThe function temperature_coefficient_plot queries the specified data and produces a geographic scatterplot. The location of each point is the location of the station and the color is based on the estimate of yearly change in temperature at the station in the given time interval.\ndef temperature_coefficient_plot(country, year_begin, year_end, month, min_obs, **kwargs):\n    '''\n    Inputs: a country, a bounded time interval, a month, minimum data points to be considered, and optional\n    plotting arguments\n    Returns: a geographic plot indicating the changes in temperature over time\n    '''\n    #obtain and clean the data\n    df = query_climate_database(db_file = \"hw1.db\", country = country, year_begin = year_begin, year_end = year_end, month = month) #read in the data using previously defined function\n    counts = df.groupby([\"NAME\", \"Month\"])[\"Year\"].transform(len)\n    df = df[counts &gt;= min_obs]\n    coefs = df.groupby([\"NAME\", \"Month\", \"LATITUDE\", \"LONGITUDE\"]).apply(coef) #find the estimated yearly change in temperature for each station\n    coefs = coefs.round(3) # round data to 3 decimal places\n    coefs = coefs.reset_index()\n    coefs = coefs.rename(columns = {0 : \"Estimated Yearly Change (C)\"})\n\n    #create the plot\n    title = \"Estimates of Yearly Increase in Temperature in {a} for stations in {b}, years {c} - {d}\"\\\n    .format(a=datetime.date(2021, month, 1).strftime('%B'), b=country, c=year_begin, d=year_end)\n    fig = px.scatter_mapbox(coefs,\n                            lat = \"LATITUDE\",\n                            lon = \"LONGITUDE\",\n                            hover_name = \"NAME\",\n                            color = \"Estimated Yearly Change (C)\",\n                            title = title,\n                            **kwargs)\n    return fig\nHere is an example of using the temperature_coefficient_plot function to visualize the estimated change in temperature across stations in India in January from 1980 to 2020.\ncolor_map = px.colors.diverging.RdGy_r \n\nfig = temperature_coefficient_plot(country = \"India\", year_begin = 1980, year_end = 2020, month = 1, \n                                   min_obs = 10,\n                                   zoom = 2,\n                                   mapbox_style=\"carto-positron\",\n                                   color_continuous_scale=color_map)\nfig.show()\n\n\n\noutput\n\n\n\n\n\nThe visualization I chose answers the question: How is the mean temperature per year changing in comparison to the overall mean temperature?\nThe function diff_from_mean_temp function takes in the same arguments as the query_climate_database: country, year_begin, year_end, and month. With the returned dataframe, it takes the mean temperature over the entire time period and then finds the difference between the mean temperature of each year and the overall mean temperature.\ndef diff_from_mean_temp(country, year_begin, year_end, month, **kwargs):\n    '''\n    Input: a country, a bounded time interval, and a month\n    Returns: a barplot comparing the yearly temperature to the average temperature over the interval\n    '''\n    df = query_climate_database(\"hw1.db\", country, year_begin, year_end, month) \n    mean = np.mean(df[\"Temp\"]) #overall mean temperature of the time interval\n    df = df.groupby([\"Year\"])[\"Temp\"].aggregate(np.mean) #find mean temperature per year\n    df = df.reset_index()\n    df[\"Difference (C)\"] = df[\"Temp\"] - mean #compare mean temperature of year to mean temperature over entire time interval\n    df= df.round(3) #round to 3 decimal places\n    df[\"col\"] = np.where(df[\"Difference (C)\"]&gt;=0, 'red', 'blue')\n\n    #create the plot\n    title = \"Difference in Mean Temperature in {a} for stations in {b} from {c} to {d}\"\\\n    .format(a=datetime.date(2021, month, 1).strftime('%B'), b=country, c=year_begin, d=year_end)\n    fig = px.bar(df, x = \"Year\", y = \"Difference (C)\",\n                hover_data = [\"Year\", \"Difference (C)\"], title = title, color = \"col\", **kwargs)\n    fig.update_layout(showlegend=False) \n    return fig\nHere is an example of using the diff_from_mean_temp function to visualize the difference in mean temperature in China in March from 1980 to 2020.\nfig = diff_from_mean_temp(\"China\", 1980, 2020, 3)\nfig.show()\n Here, the positive red bars indicate that the temperature readings that year were above the mean, and negative blue bars indicate that temperature readings that year were below the mean.\n\n\n\nThe visualization I chose answers the question: How is does temperature vary within regions of a country in a given year?\nThe function query_country_year extracts the relevant data, and the output is passed to year_diff to calculate the difference between the average temperature in the warmest month and the coldest month, at the station level.\ndef query_country_year(db_file, country, year):\n    '''\n    Returns: a dataframe of all temperatures in a country in a single year\n    '''\n    conn = sqlite3.connect(db_file)\n    #cursor = conn.cursor()\n    cmd = f\"\"\"\n    SELECT S.name, S.latitude, S.longitude, C.name, T.year, T.month, T.temp\n    FROM temperatures T\n    LEFT JOIN stations S ON T.id = S.id\n    LEFT JOIN countries C ON C.'FIPS_10-4' = S.'FIPS_10-4'\n    WHERE T.year = {year} AND C.Name = '{country}'\n    \"\"\"\n    \n    df = pd.read_sql_query(cmd, conn)\n    return df\ndef year_diff(df):\n    '''\n    Computes temperature difference between warmest and coldest month\n    '''\n    df_group = df.groupby([\"NAME\"])\n    obs_filter = df_group.count()[\"Name\"]&gt;=12\n    temp_diff = (df_group.max()[['Temp']] - df_group.min()[['Temp']])[obs_filter]\n    coords = df.groupby([\"NAME\"]).first()[[\"LATITUDE\",\"LONGITUDE\"]][obs_filter]\n    x = pd.merge(temp_diff,coords,on='NAME')\n    x = x.rename(columns={'Temp':\"Temperature difference\"})\n    x = x.reset_index()\n    return x\nThe function seasonal_difference_plot takes in a country and a year, and creates a scatterplot of the difference in temperature between the warmest and coolest month of that year.\ndef seasonal_difference_plot(country, year,**kwargs):\n    x = year_diff(query_country_year(\"hw1.db\", country, year))\n    title = f\"Difference in temperature between warmest and coolest month in {year} for stations in {country}\"\n    fig = px.scatter_mapbox(x,\n                            lat = \"LATITUDE\",\n                            lon = \"LONGITUDE\",\n                            hover_name = \"NAME\",\n                            color = \"Temperature difference\",\n                            hover_data={\n                                \"LATITUDE\":':.3f',\n                                \"LONGITUDE\":':.3f',\n                                \"Temperature difference\":':.3f'\n                            },\n                            title = title,\n                            color_continuous_scale=color_map,\n                            **kwargs)\n\n    return fig\nAn example can be seen with Mexico in the year 2020.\nfig = seasonal_difference_plot('Mexico', 2020,\n                               mapbox_style=\"carto-positron\",\n                               zoom=1)\npio.write_image(fig, \"seasonal-diff-barplot.png\")\nfig.show()\n\n\n\noutput\n\n\n\n\n\nThe last visualization I chose answers the question: How does temperature vary across months in a given country? The function query_year_range extracts the relevant data and creates a pandas dataframe from our database. We use the LEFT JOIN keyword to merge the three tables, and the WHERE to specify the conditions (a country and two integers that give the earliest and latest years).\ndef query_country_year_range(db_file, country, year_begin, year_end):\n    '''\n    returns dataframe of all temperatures in a country in a single year.\n    '''\n    conn = sqlite3.connect(db_file)\n    \n    cmd = f\"\"\"\n    SELECT S.name, S.latitude, S.longitude, C.name, T.year, T.month, T.temp\n    FROM temperatures T\n    LEFT JOIN stations S ON T.id = S.id\n    LEFT JOIN countries C ON C.'FIPS 10-4' = S.'FIPS 10-4'\n    WHERE C.name = ? AND T.year &gt;= {year_begin} AND T.year &lt;= {year_end}\n    \"\"\"\n    \n    df = pd.read_sql_query(cmd, conn, params=(country,))\n    return df\nThe function facet_hist takes in a country and two integers for years, and creates a faceted histogram of the temperatures for each month.\ndef facet_hist(country, year_begin, year_end, **kwargs):\n    '''\n    Inputs:\n    '''\n    df = query_country_year_range(\"hw1.db\", country, year_begin, year_end) \n    df.sort_values([\"Year\", \"Month\", \"Temp\"], inplace = True)\n    \n    title = f\"Distribution of Monthly Temperature in {country} between {year_begin} and {year_end}\"\n    fig = px.histogram(df,\n                       x = \"Temp\", \n                       color = \"Year\",\n                       opacity = 0.8, \n                       nbins = 20,\n                       barmode='group',\n                       histnorm = 'percent',\n                       width = 900,\n                       height = 1500,\n                       facet_col = 'Month',\n                       facet_col_wrap = 3, \n                       title = title,\n                        **kwargs)\n    return fig\nAn example can be seen with Canada in the 2018-2020.\nfig = facet_hist(\"Canada\", 2018, 2020)\nfig.show()\n\n\n\noutput"
  },
  {
    "objectID": "posts/hw3/index.html",
    "href": "posts/hw3/index.html",
    "title": "HW3",
    "section": "",
    "text": "First, let’s import the necessary libraries.\nfrom flask import Flask, g, render_template, request\n\nimport sklearn as sk\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pickle\nimport os\nfrom matplotlib.backends.backend_agg import FigureCanvasAgg as FigureCanvas\nfrom matplotlib.figure import Figure\n\nimport io\nimport base64\nimport sqlite3\nimport sys\n\napp = Flask(__name__)\nNext, let’s define the get_message_db() function.\ndef get_message_db():\n    try:\n        return g.message_db\n    except:\n        g.message_db = sqlite3.connect(\"messages_db.sqlite\")\n        cmd = '''\n        CREATE TABLE IF NOT EXISTS messages (\n            id INTEGER PRIMARY KEY,\n            handle TEXT,\n            message TEXT\n        )\n        '''\n        cursor = g.message_db.cursor()\n        cursor.execute(cmd)\n        return g.message_db\nThe purpose of this is to ensure that there is a connection to a SQLite database where messages can be stored. It either returns an existing connection stored in the Flask global object (g.message_db) or creates a new connection if one does not exist. After creating a new connection, the function executes a SQL command to create a table named messages if it doesn’t already exist. The table has three columns: id, handle, and message.\nThe next function is the insert_message() function.\ndef insert_message(request):\n    message = request.form[\"message\"]\n    handle = request.form[\"handle\"]\n\n    conn = get_message_db()\n    cursor = conn.cursor()\n    cursor.execute(\"INSERT INTO messages (handle, message) VALUES (?, ?)\", (handle, message))\n    conn.commit()\n    cursor.close()\n\n    return message, handle\nThis function takes in a request object and returns the message and handle that were inserted into the database. The overall purpose of this function is to insert messages into the database.\nNext, we can define the random_messages() function.\ndef random_messages(n):\n    conn = get_message_db()\n    cursor = conn.cursor()\n    cursor.execute(\"SELECT handle, message FROM messages ORDER BY RANDOM() LIMIT ?\", (n,))\n    messages = cursor.fetchall()\n    cursor.close()\n    return messages\nThis function takes an integer n as its argument, indicating the number of random messages to retrieve from the database. After obtaining the connection, the function creates a cursor object to execute SQL commands. This function is useful for displaying random messages to users.\nThe last function we define is the render_submit_template().\ndef render_submit_template():\n    if request.method == 'GET':\n        return render_template('submit.html')\n    elif request.method == 'POST':\n        message, handle = insert_message(request)\n        return render_template('submit.html')\nThe purpose of this function is to handle rendering of the submit.html template for both initial GET requests (to serve the form) and POST requests (after form submission). If the request method is ‘POST’, insert_message(request) is called.\nFinally, let’s define our app routes.\n@app.route('/')\ndef home():\n    return render_template('base.html')\n\n@app.route('/submit/', methods=['POST', 'GET'])\ndef submit():\n    return render_submit_template()\n\n@app.route('/view/')\ndef view():\n    messages = random_messages(5)  # Get 5 random messages\n    return render_template('view.html', messages=messages)\n\nif __name__ == \"__main__\":\n    app.run(debug=True, host=\"0.0.0.0\", port=int(os.environ.get(\"PORT\", 8080)))\n\n\n\nsubmit.html is one of the template files used in the app.\n{% extends \"base.html\" %} \n\n{% block content %}\n    &lt;form method=\"post\" enctype=\"multipart/form-data\"&gt;\n        &lt;label for=\"message\"&gt;Message:&lt;/label&gt;&lt;br&gt;\n        &lt;input type=\"text\" id=\"message\" name=\"message\"&gt;&lt;br&gt;\n        &lt;label for=\"name\"&gt;Your Name:&lt;/label&gt;&lt;br&gt;\n        &lt;input type=\"text\" id=\"handle\" name=\"handle\"&gt;&lt;br&gt;&lt;br&gt;\n        &lt;input type=\"submit\" value=\"Submit form\"&gt;\n    &lt;/form&gt;\n{% endblock %}\nThe first line indicates that this template extends another template named base.html and inherits the structure and layout. The content block creates fields from user input, and defines an HTML form with fields for a message and the user’s name.\n\n\n\nThis screencap shows an example of a user submitting a message. In this case, the message is “Hello” while the handle is “Jessica Xiao”. \nThis screencap shows an example of a user viewing submitted messages. When the user clicks “view”, they will be able to view 5 randomly generated messages from the database."
  },
  {
    "objectID": "posts/hw3/index.html#write-the-app.py-file",
    "href": "posts/hw3/index.html#write-the-app.py-file",
    "title": "HW3",
    "section": "",
    "text": "First, let’s import the necessary libraries.\nfrom flask import Flask, g, render_template, request\n\nimport sklearn as sk\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pickle\nimport os\nfrom matplotlib.backends.backend_agg import FigureCanvasAgg as FigureCanvas\nfrom matplotlib.figure import Figure\n\nimport io\nimport base64\nimport sqlite3\nimport sys\n\napp = Flask(__name__)\nNext, let’s define the get_message_db() function.\ndef get_message_db():\n    try:\n        return g.message_db\n    except:\n        g.message_db = sqlite3.connect(\"messages_db.sqlite\")\n        cmd = '''\n        CREATE TABLE IF NOT EXISTS messages (\n            id INTEGER PRIMARY KEY,\n            handle TEXT,\n            message TEXT\n        )\n        '''\n        cursor = g.message_db.cursor()\n        cursor.execute(cmd)\n        return g.message_db\nThe purpose of this is to ensure that there is a connection to a SQLite database where messages can be stored. It either returns an existing connection stored in the Flask global object (g.message_db) or creates a new connection if one does not exist. After creating a new connection, the function executes a SQL command to create a table named messages if it doesn’t already exist. The table has three columns: id, handle, and message.\nThe next function is the insert_message() function.\ndef insert_message(request):\n    message = request.form[\"message\"]\n    handle = request.form[\"handle\"]\n\n    conn = get_message_db()\n    cursor = conn.cursor()\n    cursor.execute(\"INSERT INTO messages (handle, message) VALUES (?, ?)\", (handle, message))\n    conn.commit()\n    cursor.close()\n\n    return message, handle\nThis function takes in a request object and returns the message and handle that were inserted into the database. The overall purpose of this function is to insert messages into the database.\nNext, we can define the random_messages() function.\ndef random_messages(n):\n    conn = get_message_db()\n    cursor = conn.cursor()\n    cursor.execute(\"SELECT handle, message FROM messages ORDER BY RANDOM() LIMIT ?\", (n,))\n    messages = cursor.fetchall()\n    cursor.close()\n    return messages\nThis function takes an integer n as its argument, indicating the number of random messages to retrieve from the database. After obtaining the connection, the function creates a cursor object to execute SQL commands. This function is useful for displaying random messages to users.\nThe last function we define is the render_submit_template().\ndef render_submit_template():\n    if request.method == 'GET':\n        return render_template('submit.html')\n    elif request.method == 'POST':\n        message, handle = insert_message(request)\n        return render_template('submit.html')\nThe purpose of this function is to handle rendering of the submit.html template for both initial GET requests (to serve the form) and POST requests (after form submission). If the request method is ‘POST’, insert_message(request) is called.\nFinally, let’s define our app routes.\n@app.route('/')\ndef home():\n    return render_template('base.html')\n\n@app.route('/submit/', methods=['POST', 'GET'])\ndef submit():\n    return render_submit_template()\n\n@app.route('/view/')\ndef view():\n    messages = random_messages(5)  # Get 5 random messages\n    return render_template('view.html', messages=messages)\n\nif __name__ == \"__main__\":\n    app.run(debug=True, host=\"0.0.0.0\", port=int(os.environ.get(\"PORT\", 8080)))"
  },
  {
    "objectID": "posts/hw3/index.html#explanation-of-base.html",
    "href": "posts/hw3/index.html#explanation-of-base.html",
    "title": "HW3",
    "section": "",
    "text": "submit.html is one of the template files used in the app.\n{% extends \"base.html\" %} \n\n{% block content %}\n    &lt;form method=\"post\" enctype=\"multipart/form-data\"&gt;\n        &lt;label for=\"message\"&gt;Message:&lt;/label&gt;&lt;br&gt;\n        &lt;input type=\"text\" id=\"message\" name=\"message\"&gt;&lt;br&gt;\n        &lt;label for=\"name\"&gt;Your Name:&lt;/label&gt;&lt;br&gt;\n        &lt;input type=\"text\" id=\"handle\" name=\"handle\"&gt;&lt;br&gt;&lt;br&gt;\n        &lt;input type=\"submit\" value=\"Submit form\"&gt;\n    &lt;/form&gt;\n{% endblock %}\nThe first line indicates that this template extends another template named base.html and inherits the structure and layout. The content block creates fields from user input, and defines an HTML form with fields for a message and the user’s name."
  },
  {
    "objectID": "posts/hw3/index.html#examples-of-user-submissions",
    "href": "posts/hw3/index.html#examples-of-user-submissions",
    "title": "HW3",
    "section": "",
    "text": "This screencap shows an example of a user submitting a message. In this case, the message is “Hello” while the handle is “Jessica Xiao”. \nThis screencap shows an example of a user viewing submitted messages. When the user clicks “view”, they will be able to view 5 randomly generated messages from the database."
  },
  {
    "objectID": "posts/post-with-code/index.html",
    "href": "posts/post-with-code/index.html",
    "title": "Post With Code",
    "section": "",
    "text": "This is a post with executable code."
  },
  {
    "objectID": "posts/bruin/index.html",
    "href": "posts/bruin/index.html",
    "title": "Creating posts",
    "section": "",
    "text": "HW0\nIn this blog post, we will be creating a data visualization on the Palmer Penguins dataset.\n\nImporting libraries and reading data\nFirst, let’s import the necessary libararies and read the data into python.\nimport pandas as pd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\nurl = \"https://raw.githubusercontent.com/pic16b-ucla/24W/main/datasets/palmer_penguins.csv\"\npenguins = pd.read_csv(url)\nAs seen in the code above, pandas is used to read the data. We will next use seaborn and matplotlib to create our plot.\n\n\nCreating the scatterplot\nNext, we will use the seaborn library to create our scatterplot. The scatterplot function takes the in the arguments data, x, y, and hue.\nsns.scatterplot(data=penguins, x=\"Culmen Length (mm)\", y=\"Body Mass (g)\", hue=\"Species\")\n From this plot, we can see that there is a postive correlation between culmen length and body mass. Furthermore, we can see the differences between the 3 species of penguins.\nTo improve our visualization, let’s add a title and move the legend to the side of the plot.\nplt.legend(bbox_to_anchor=(1.05, 1),loc=2)\nplt.title(\"Scatter Plot of Culmen Length vs. Body Mass\")\n\n\n\noutput"
  },
  {
    "objectID": "posts/hw4/index.html",
    "href": "posts/hw4/index.html",
    "title": "HW4",
    "section": "",
    "text": "In the homework, we will be conducting a simulation of two-dimensional heat diffusion in various ways. First, let’s define our initial conditions and import the necessary libraries.\nN = 101\nepsilon = 0.2\niterations = 2700\nplot_interval = 300\n\nimport numpy as np\nfrom matplotlib import pyplot as plt\n# construct initial condition: 1 unit of heat at midpoint. \nu0 = np.zeros((N, N))\nu0[int(N/2), int(N/2)] = 1.0\nplt.imshow(u0)\nHere, we have the initial condition as in the 1D case: putting 1 unit of heat at the midpoint. \n\n\nFirst, let’s use matrix-vector multiplication to simulate the heat diffusion in the 2D space. The vector here is created by flattening the current solution.\ndef advance_time_matvecmul(A, u, epsilon):\n    \"\"\"Advances the simulation by one timestep, via matrix-vector multiplication\n    Args:\n        A: The 2d finite difference matrix, N^2 x N^2. \n        u: N x N grid state at timestep k.\n        epsilon: stability constant.\n\n    Returns:\n        N x N Grid state at timestep k+1.\n    \"\"\"\n    N = u.shape[0]\n    u = u + epsilon * (A @ u.flatten()).reshape((N, N))\n    return u\nThis function takes the value N as the argument and returns the corresponding matrix A.\ndef get_A(N):\n    n = N * N\n    diagonals = [-4 * np.ones(n), np.ones(n-1), np.ones(n-1), np.ones(n-N), np.ones(n-N)]\n    diagonals[1][(N-1)::N] = 0\n    diagonals[2][(N-1)::N] = 0\n    A = np.diag(diagonals[0]) + np.diag(diagonals[1], 1) + np.diag(diagonals[2], -1) + np.diag(diagonals[3], N) + np.diag(diagonals[4], -N)\n    return A\nAfter defining advance_time_matvecmul and get_A, we can run the simulation to visualize the diffusion of heat every 300 iterations using a heatmap.\nstart_time = time.time() #start time\n# Initialize intermediate solutions array for visualization\nintermediate_solutions = []\n\n# Construct finite difference matrix\nA = get_A(N)\n\n# Run simulation\ncurrent_solution = u0.copy()\nfor i in range(iterations):\n    current_solution = advance_time_matvecmul(A, current_solution, epsilon)\n    if (i + 1) % plot_interval == 0:\n        intermediate_solutions.append(current_solution)\n\nend_time = time.time() # end time excluding time for visualization\n        \n# Visualize diffusion at specified intervals\nplt.figure(figsize=(12, 12))\nfor i, solution in enumerate(intermediate_solutions):\n    plt.subplot(3, 3, i+1)\n    plt.imshow(solution, cmap='hot')\n    plt.title(f\"Iteration {(i+1)*plot_interval}\")\n    plt.axis('off')\n\nplt.tight_layout()\nplt.show()\nelapsed_time = end_time - start_time\nprint(elapsed_time) #44.71136999130249\nWe can see that using matrix multiplication is quite slow, and takes 44.71136999130249 seconds to generate the heat diffusion simulation below. \n\n\n\n\n\n\nA much efficient way to generate this simulation is through direct operation with numpy. Here, we can define advance_time_numpy in heat_equation.py and run the simulation in intervals similar to the other methods.\ndef advance_time_numpy(u, epsilon):\n    \"\"\"Advances the solution by one timestep using numpy vectorized operations.\n    \n    Args:\n        u: N x N grid state at timestep k.\n        epsilon: stability constant.\n\n    Returns:\n        N x N grid state at timestep k+1.\n    \"\"\"\n    # Pad zeros to form an (N+2) x (N+2) array\n    padded_u = np.pad(u, 1, mode='constant')\n\n    # Compute the Laplacian using np.roll()\n    laplacian = (\n        np.roll(padded_u, 1, axis=0) + np.roll(padded_u, -1, axis=0) +\n        np.roll(padded_u, 1, axis=1) + np.roll(padded_u, -1, axis=1) -\n        4 * padded_u\n    )\n\n    # Update the solution using the heat equation\n    new_u = u + epsilon * laplacian[1:-1, 1:-1]\n\n    return new_u\nstart_time = time.time()\n\n# Construct initial condition\nu0 = np.zeros((N, N))\nu0[int(N/2), int(N/2)] = 1.0\n\n# Initialize intermediate solutions array for visualization\nintermediate_solutions_numpy = []\n\n# Run simulation with numpy\ncurrent_solution = u0.copy()\nfor i in range(iterations):\n    current_solution = advance_time_numpy(current_solution, epsilon)\n    if (i + 1) % plot_interval == 0:\n        intermediate_solutions_numpy.append(current_solution)\n\nend_time = time.time()\n\n# Visualize diffusion at specified intervals\nplt.figure(figsize=(12, 12))\nfor i, solution in enumerate(intermediate_solutions_numpy):\n    plt.subplot(3, 3, i+1)\n    plt.imshow(solution, cmap='hot')\n    plt.title(f\"Iteration {(i+1)*plot_interval}\")\n    plt.axis('off')\n\nplt.tight_layout()\nplt.show() \nelapsed_time = end_time - start_time\nprint(elapsed_time) #0.18757390975952148\nWe can see that using direct operation with numpy is significantly faster, only taking 0.18757390975952148 seconds to run the simulation. \n\n\n\nFinally, we can use JAX and define advance_time_jax without using a sparse matrix.\n@jit\ndef advance_time_jax(u, epsilon):\n    \"\"\"Advances the solution by one timestep using JAX and JIT compilation\n    Args:\n        u: N x N grid state at timestep k.\n        epsilon: stability constant.\n\n    Returns:\n        N x N Grid state at timestep k+1.\n    \"\"\"\n    # Extract the size of the grid\n    N = u.shape[0]\n    \n    # Create a padded version of 'u' to simplify boundary computations\n    padded_u = jnp.pad(u, 1, mode='constant')\n    \n    # Calculate the updates in a vectorized manner\n    update_value = epsilon * (padded_u[:-2, 1:-1] + padded_u[2:, 1:-1] + padded_u[1:-1, :-2] + padded_u[1:-1, 2:] - 4 * u)\n    u_new = u + update_value\n    \n    return u_new\nstart_time = time.time()\n\n# Construct initial condition\nu0 = np.zeros((N, N))\nu0[int(N/2), int(N/2)] = 1.0\n\n# Initialize intermediate solutions array for visualization\nintermediate_solutions_jax = []\n\n# Run simulation with JAX\ncurrent_solution = u0.copy()\nfor i in range(iterations):\n    current_solution = advance_time_jax(current_solution, epsilon)\n    if (i + 1) % plot_interval == 0:\n        intermediate_solutions_jax.append(current_solution)\n\nend_time = time.time()\n\n# Visualize diffusion at specified intervals\nplt.figure(figsize=(12, 12))\nfor i, solution in enumerate(intermediate_solutions_jax):\n    plt.subplot(3, 3, i+1)\n    plt.imshow(solution, cmap='hot')\n    plt.title(f\"Iteration {(i+1)*plot_interval}\")\n    plt.axis('off')\n\nplt.tight_layout()\nplt.show() \nelapsed_time = end_time - start_time\nprint(elapsed_time) #0.07134509086608887\nUsing JAX only takes us 0.07134509086608887 seconds to generate the simulation. This method is the fastest, and has clean and short code that is easy to follow. \n\n\n\nThe full implementation for heat_equation.py can be seen below.\nN = 101\nepsilon = 0.2\n\nimport numpy as np\nfrom matplotlib import pyplot as plt\nimport jax.numpy as jnp\nimport jax\nfrom jax import jit, ops\nfrom jax import lax\nfrom jax.experimental.sparse import bcoo\nimport jax.scipy.sparse as sps\n\n# construct initial condition: 1 unit of heat at midpoint. \nu0 = np.zeros((N, N))\nu0[int(N/2), int(N/2)] = 1.0\nplt.imshow(u0)\n\ndef advance_time_matvecmul(A, u, epsilon):\n    \"\"\"Advances the simulation by one timestep, via matrix-vector multiplication\n    Args:\n        A: The 2d finite difference matrix, N^2 x N^2. \n        u: N x N grid state at timestep k.\n        epsilon: stability constant.\n\n    Returns:\n        N x N Grid state at timestep k+1.\n    \"\"\"\n    N = u.shape[0]\n    u = u + epsilon * (A @ u.flatten()).reshape((N, N))\n    return u\n\n# @jit\ndef advance_time_matvecmul_sparse(A, u, epsilon):\n    \"\"\"Advances the simulation by one timestep, via matrix-vector multiplication\n    Args:\n        A: The 2d finite difference matrix, N^2 x N^2. \n        u: N x N grid state at timestep k.\n        epsilon: stability constant.\n\n    Returns:\n        N x N Grid state at timestep k+1.\n    \"\"\"\n    N = u.shape[0]\n    \n    # Convert u to a vector\n    u_vec = u.flatten()\n    \n    # Sparse matrix-vector multiplication\n    result_vec = bcoo.bcoo_multiply_dense(A, u_vec)\n    \n    # Reshape the result vector to N x N grid\n    result_grid = result_vec.reshape((N, N))\n    \n    # Update the grid state\n    u_new = u + epsilon * result_grid\n    return u_new\n\ndef get_A(N):\n    n = N * N\n    diagonals = [-4 * np.ones(n), np.ones(n-1), np.ones(n-1), np.ones(n-N), np.ones(n-N)]\n    diagonals[1][(N-1)::N] = 0\n    diagonals[2][(N-1)::N] = 0\n    A = np.diag(diagonals[0]) + np.diag(diagonals[1], 1) + np.diag(diagonals[2], -1) + np.diag(diagonals[3], N) + np.diag(diagonals[4], -N)\n    return A\n\n\ndef get_sparse_A(N):\n    \"\"\"Constructs the finite difference matrix A for 2D heat equation in a sparse format using JAX's experimental sparse module.\n    \n    Args:\n        N: Size of the grid.\n        \n    Returns:\n        A_sp_matrix: The sparse representation of finite difference matrix in COO format.\n    \"\"\"\n    n = N * N\n\n    # Initialize data for diagonals\n    data = [-4 * jnp.ones(n), jnp.ones(n-1), jnp.ones(n-1), jnp.ones(n-N), jnp.ones(n-N)]\n\n    # Modify diagonals\n    data[1] = jnp.where(jnp.arange(1, n) % N == 0, 0, data[1])\n    data[2] = jnp.where(jnp.arange(0, n-1) % N == 0, 0, data[2])\n\n   # rows = jnp.tile(jnp.arange(N), N)\n   # cols = jnp.repeat(jnp.arange(N), N)\n\n    # Create sparse matrix in BCOO format\n   # offsets = [-N, -1, 0, 1, N]\n    A_sp_matrix = bcoo.BCOO(data, shape=(n, n), indices_sorted=True)\n\n    return A_sp_matrix\n'''\ndef get_sparse_A(N):\n    \"\"\"Constructs the finite difference matrix A for 2D heat equation in a sparse format.\n    \n    Args:\n        N: Size of the grid.\n        \n    Returns:\n        A_sp_matrix: The sparse representation of finite difference matrix.\n    \"\"\"\n    n = N * N\n    diagonals = [-4 * jnp.ones(n), jnp.ones(n-1), jnp.ones(n-1), jnp.ones(n-N), jnp.ones(n-N)]\n    diagonals[1] = jnp.where(jnp.arange(1, n) % N == 0, 0, diagonals[1])\n    diagonals[2] = jnp.where(jnp.arange(0, n-1) % N == 0, 0, diagonals[2])\n    return A_sp_matrix\n'''\n\n# part 3\ndef advance_time_numpy(u, epsilon):\n    \"\"\"Advances the solution by one timestep using numpy vectorized operations.\n    \n    Args:\n        u: N x N grid state at timestep k.\n        epsilon: stability constant.\n\n    Returns:\n        N x N grid state at timestep k+1.\n    \"\"\"\n    # Pad zeros to form an (N+2) x (N+2) array\n    padded_u = np.pad(u, 1, mode='constant')\n\n    # Compute the Laplacian using np.roll()\n    laplacian = (\n        np.roll(padded_u, 1, axis=0) + np.roll(padded_u, -1, axis=0) +\n        np.roll(padded_u, 1, axis=1) + np.roll(padded_u, -1, axis=1) -\n        4 * padded_u\n    )\n\n    # Update the solution using the heat equation\n    new_u = u + epsilon * laplacian[1:-1, 1:-1]\n\n    return new_u\n\n@jit\ndef advance_time_jax(u, epsilon):\n    \"\"\"Advances the solution by one timestep using JAX and JIT compilation\n    Args:\n        u: N x N grid state at timestep k.\n        epsilon: stability constant.\n\n    Returns:\n        N x N Grid state at timestep k+1.\n    \"\"\"\n    # Extract the size of the grid\n    N = u.shape[0]\n    \n    # Create a padded version of 'u' to simplify boundary computations\n    padded_u = jnp.pad(u, 1, mode='constant')\n    \n    # Calculate the updates in a vectorized manner\n    update_value = epsilon * (padded_u[:-2, 1:-1] + padded_u[2:, 1:-1] + padded_u[1:-1, :-2] + padded_u[1:-1, 2:] - 4 * u)\n    u_new = u + update_value\n    \n    return u_new\n\n\n# JIT compile the function\n#advance_time_jax_jit = jit(advance_time_jax)"
  },
  {
    "objectID": "posts/hw4/index.html#with-matrix-multiplication",
    "href": "posts/hw4/index.html#with-matrix-multiplication",
    "title": "HW4",
    "section": "",
    "text": "First, let’s use matrix-vector multiplication to simulate the heat diffusion in the 2D space. The vector here is created by flattening the current solution.\ndef advance_time_matvecmul(A, u, epsilon):\n    \"\"\"Advances the simulation by one timestep, via matrix-vector multiplication\n    Args:\n        A: The 2d finite difference matrix, N^2 x N^2. \n        u: N x N grid state at timestep k.\n        epsilon: stability constant.\n\n    Returns:\n        N x N Grid state at timestep k+1.\n    \"\"\"\n    N = u.shape[0]\n    u = u + epsilon * (A @ u.flatten()).reshape((N, N))\n    return u\nThis function takes the value N as the argument and returns the corresponding matrix A.\ndef get_A(N):\n    n = N * N\n    diagonals = [-4 * np.ones(n), np.ones(n-1), np.ones(n-1), np.ones(n-N), np.ones(n-N)]\n    diagonals[1][(N-1)::N] = 0\n    diagonals[2][(N-1)::N] = 0\n    A = np.diag(diagonals[0]) + np.diag(diagonals[1], 1) + np.diag(diagonals[2], -1) + np.diag(diagonals[3], N) + np.diag(diagonals[4], -N)\n    return A\nAfter defining advance_time_matvecmul and get_A, we can run the simulation to visualize the diffusion of heat every 300 iterations using a heatmap.\nstart_time = time.time() #start time\n# Initialize intermediate solutions array for visualization\nintermediate_solutions = []\n\n# Construct finite difference matrix\nA = get_A(N)\n\n# Run simulation\ncurrent_solution = u0.copy()\nfor i in range(iterations):\n    current_solution = advance_time_matvecmul(A, current_solution, epsilon)\n    if (i + 1) % plot_interval == 0:\n        intermediate_solutions.append(current_solution)\n\nend_time = time.time() # end time excluding time for visualization\n        \n# Visualize diffusion at specified intervals\nplt.figure(figsize=(12, 12))\nfor i, solution in enumerate(intermediate_solutions):\n    plt.subplot(3, 3, i+1)\n    plt.imshow(solution, cmap='hot')\n    plt.title(f\"Iteration {(i+1)*plot_interval}\")\n    plt.axis('off')\n\nplt.tight_layout()\nplt.show()\nelapsed_time = end_time - start_time\nprint(elapsed_time) #44.71136999130249\nWe can see that using matrix multiplication is quite slow, and takes 44.71136999130249 seconds to generate the heat diffusion simulation below."
  },
  {
    "objectID": "posts/hw4/index.html#direct-operation-with-numpy",
    "href": "posts/hw4/index.html#direct-operation-with-numpy",
    "title": "HW4",
    "section": "",
    "text": "A much efficient way to generate this simulation is through direct operation with numpy. Here, we can define advance_time_numpy in heat_equation.py and run the simulation in intervals similar to the other methods.\ndef advance_time_numpy(u, epsilon):\n    \"\"\"Advances the solution by one timestep using numpy vectorized operations.\n    \n    Args:\n        u: N x N grid state at timestep k.\n        epsilon: stability constant.\n\n    Returns:\n        N x N grid state at timestep k+1.\n    \"\"\"\n    # Pad zeros to form an (N+2) x (N+2) array\n    padded_u = np.pad(u, 1, mode='constant')\n\n    # Compute the Laplacian using np.roll()\n    laplacian = (\n        np.roll(padded_u, 1, axis=0) + np.roll(padded_u, -1, axis=0) +\n        np.roll(padded_u, 1, axis=1) + np.roll(padded_u, -1, axis=1) -\n        4 * padded_u\n    )\n\n    # Update the solution using the heat equation\n    new_u = u + epsilon * laplacian[1:-1, 1:-1]\n\n    return new_u\nstart_time = time.time()\n\n# Construct initial condition\nu0 = np.zeros((N, N))\nu0[int(N/2), int(N/2)] = 1.0\n\n# Initialize intermediate solutions array for visualization\nintermediate_solutions_numpy = []\n\n# Run simulation with numpy\ncurrent_solution = u0.copy()\nfor i in range(iterations):\n    current_solution = advance_time_numpy(current_solution, epsilon)\n    if (i + 1) % plot_interval == 0:\n        intermediate_solutions_numpy.append(current_solution)\n\nend_time = time.time()\n\n# Visualize diffusion at specified intervals\nplt.figure(figsize=(12, 12))\nfor i, solution in enumerate(intermediate_solutions_numpy):\n    plt.subplot(3, 3, i+1)\n    plt.imshow(solution, cmap='hot')\n    plt.title(f\"Iteration {(i+1)*plot_interval}\")\n    plt.axis('off')\n\nplt.tight_layout()\nplt.show() \nelapsed_time = end_time - start_time\nprint(elapsed_time) #0.18757390975952148\nWe can see that using direct operation with numpy is significantly faster, only taking 0.18757390975952148 seconds to run the simulation."
  },
  {
    "objectID": "posts/hw4/index.html#with-jax",
    "href": "posts/hw4/index.html#with-jax",
    "title": "HW4",
    "section": "",
    "text": "Finally, we can use JAX and define advance_time_jax without using a sparse matrix.\n@jit\ndef advance_time_jax(u, epsilon):\n    \"\"\"Advances the solution by one timestep using JAX and JIT compilation\n    Args:\n        u: N x N grid state at timestep k.\n        epsilon: stability constant.\n\n    Returns:\n        N x N Grid state at timestep k+1.\n    \"\"\"\n    # Extract the size of the grid\n    N = u.shape[0]\n    \n    # Create a padded version of 'u' to simplify boundary computations\n    padded_u = jnp.pad(u, 1, mode='constant')\n    \n    # Calculate the updates in a vectorized manner\n    update_value = epsilon * (padded_u[:-2, 1:-1] + padded_u[2:, 1:-1] + padded_u[1:-1, :-2] + padded_u[1:-1, 2:] - 4 * u)\n    u_new = u + update_value\n    \n    return u_new\nstart_time = time.time()\n\n# Construct initial condition\nu0 = np.zeros((N, N))\nu0[int(N/2), int(N/2)] = 1.0\n\n# Initialize intermediate solutions array for visualization\nintermediate_solutions_jax = []\n\n# Run simulation with JAX\ncurrent_solution = u0.copy()\nfor i in range(iterations):\n    current_solution = advance_time_jax(current_solution, epsilon)\n    if (i + 1) % plot_interval == 0:\n        intermediate_solutions_jax.append(current_solution)\n\nend_time = time.time()\n\n# Visualize diffusion at specified intervals\nplt.figure(figsize=(12, 12))\nfor i, solution in enumerate(intermediate_solutions_jax):\n    plt.subplot(3, 3, i+1)\n    plt.imshow(solution, cmap='hot')\n    plt.title(f\"Iteration {(i+1)*plot_interval}\")\n    plt.axis('off')\n\nplt.tight_layout()\nplt.show() \nelapsed_time = end_time - start_time\nprint(elapsed_time) #0.07134509086608887\nUsing JAX only takes us 0.07134509086608887 seconds to generate the simulation. This method is the fastest, and has clean and short code that is easy to follow."
  },
  {
    "objectID": "posts/hw4/index.html#full-code-for-heat_equation.py",
    "href": "posts/hw4/index.html#full-code-for-heat_equation.py",
    "title": "HW4",
    "section": "",
    "text": "The full implementation for heat_equation.py can be seen below.\nN = 101\nepsilon = 0.2\n\nimport numpy as np\nfrom matplotlib import pyplot as plt\nimport jax.numpy as jnp\nimport jax\nfrom jax import jit, ops\nfrom jax import lax\nfrom jax.experimental.sparse import bcoo\nimport jax.scipy.sparse as sps\n\n# construct initial condition: 1 unit of heat at midpoint. \nu0 = np.zeros((N, N))\nu0[int(N/2), int(N/2)] = 1.0\nplt.imshow(u0)\n\ndef advance_time_matvecmul(A, u, epsilon):\n    \"\"\"Advances the simulation by one timestep, via matrix-vector multiplication\n    Args:\n        A: The 2d finite difference matrix, N^2 x N^2. \n        u: N x N grid state at timestep k.\n        epsilon: stability constant.\n\n    Returns:\n        N x N Grid state at timestep k+1.\n    \"\"\"\n    N = u.shape[0]\n    u = u + epsilon * (A @ u.flatten()).reshape((N, N))\n    return u\n\n# @jit\ndef advance_time_matvecmul_sparse(A, u, epsilon):\n    \"\"\"Advances the simulation by one timestep, via matrix-vector multiplication\n    Args:\n        A: The 2d finite difference matrix, N^2 x N^2. \n        u: N x N grid state at timestep k.\n        epsilon: stability constant.\n\n    Returns:\n        N x N Grid state at timestep k+1.\n    \"\"\"\n    N = u.shape[0]\n    \n    # Convert u to a vector\n    u_vec = u.flatten()\n    \n    # Sparse matrix-vector multiplication\n    result_vec = bcoo.bcoo_multiply_dense(A, u_vec)\n    \n    # Reshape the result vector to N x N grid\n    result_grid = result_vec.reshape((N, N))\n    \n    # Update the grid state\n    u_new = u + epsilon * result_grid\n    return u_new\n\ndef get_A(N):\n    n = N * N\n    diagonals = [-4 * np.ones(n), np.ones(n-1), np.ones(n-1), np.ones(n-N), np.ones(n-N)]\n    diagonals[1][(N-1)::N] = 0\n    diagonals[2][(N-1)::N] = 0\n    A = np.diag(diagonals[0]) + np.diag(diagonals[1], 1) + np.diag(diagonals[2], -1) + np.diag(diagonals[3], N) + np.diag(diagonals[4], -N)\n    return A\n\n\ndef get_sparse_A(N):\n    \"\"\"Constructs the finite difference matrix A for 2D heat equation in a sparse format using JAX's experimental sparse module.\n    \n    Args:\n        N: Size of the grid.\n        \n    Returns:\n        A_sp_matrix: The sparse representation of finite difference matrix in COO format.\n    \"\"\"\n    n = N * N\n\n    # Initialize data for diagonals\n    data = [-4 * jnp.ones(n), jnp.ones(n-1), jnp.ones(n-1), jnp.ones(n-N), jnp.ones(n-N)]\n\n    # Modify diagonals\n    data[1] = jnp.where(jnp.arange(1, n) % N == 0, 0, data[1])\n    data[2] = jnp.where(jnp.arange(0, n-1) % N == 0, 0, data[2])\n\n   # rows = jnp.tile(jnp.arange(N), N)\n   # cols = jnp.repeat(jnp.arange(N), N)\n\n    # Create sparse matrix in BCOO format\n   # offsets = [-N, -1, 0, 1, N]\n    A_sp_matrix = bcoo.BCOO(data, shape=(n, n), indices_sorted=True)\n\n    return A_sp_matrix\n'''\ndef get_sparse_A(N):\n    \"\"\"Constructs the finite difference matrix A for 2D heat equation in a sparse format.\n    \n    Args:\n        N: Size of the grid.\n        \n    Returns:\n        A_sp_matrix: The sparse representation of finite difference matrix.\n    \"\"\"\n    n = N * N\n    diagonals = [-4 * jnp.ones(n), jnp.ones(n-1), jnp.ones(n-1), jnp.ones(n-N), jnp.ones(n-N)]\n    diagonals[1] = jnp.where(jnp.arange(1, n) % N == 0, 0, diagonals[1])\n    diagonals[2] = jnp.where(jnp.arange(0, n-1) % N == 0, 0, diagonals[2])\n    return A_sp_matrix\n'''\n\n# part 3\ndef advance_time_numpy(u, epsilon):\n    \"\"\"Advances the solution by one timestep using numpy vectorized operations.\n    \n    Args:\n        u: N x N grid state at timestep k.\n        epsilon: stability constant.\n\n    Returns:\n        N x N grid state at timestep k+1.\n    \"\"\"\n    # Pad zeros to form an (N+2) x (N+2) array\n    padded_u = np.pad(u, 1, mode='constant')\n\n    # Compute the Laplacian using np.roll()\n    laplacian = (\n        np.roll(padded_u, 1, axis=0) + np.roll(padded_u, -1, axis=0) +\n        np.roll(padded_u, 1, axis=1) + np.roll(padded_u, -1, axis=1) -\n        4 * padded_u\n    )\n\n    # Update the solution using the heat equation\n    new_u = u + epsilon * laplacian[1:-1, 1:-1]\n\n    return new_u\n\n@jit\ndef advance_time_jax(u, epsilon):\n    \"\"\"Advances the solution by one timestep using JAX and JIT compilation\n    Args:\n        u: N x N grid state at timestep k.\n        epsilon: stability constant.\n\n    Returns:\n        N x N Grid state at timestep k+1.\n    \"\"\"\n    # Extract the size of the grid\n    N = u.shape[0]\n    \n    # Create a padded version of 'u' to simplify boundary computations\n    padded_u = jnp.pad(u, 1, mode='constant')\n    \n    # Calculate the updates in a vectorized manner\n    update_value = epsilon * (padded_u[:-2, 1:-1] + padded_u[2:, 1:-1] + padded_u[1:-1, :-2] + padded_u[1:-1, 2:] - 4 * u)\n    u_new = u + update_value\n    \n    return u_new\n\n\n# JIT compile the function\n#advance_time_jax_jit = jit(advance_time_jax)"
  },
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "This is the first post in a Quarto blog. Welcome!\n\nSince this post doesn’t specify an explicit image, the first image in the post will be used in the listing page of posts."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "myblog",
    "section": "",
    "text": "HW4\n\n\n\n\n\n\nweek 7\n\n\nhomework\n\n\n\n\n\n\n\n\n\nMar 1, 2024\n\n\nJessica Xiao\n\n\n\n\n\n\n\n\n\n\n\n\nHW3\n\n\n\n\n\n\nweek 5\n\n\nhomework\n\n\n\n\n\n\n\n\n\nFeb 14, 2024\n\n\nJessica Xiao\n\n\n\n\n\n\n\n\n\n\n\n\nHW1\n\n\n\n\n\n\nweek 3\n\n\nhomework\n\n\n\n\n\n\n\n\n\nJan 29, 2024\n\n\nJessica Xiao\n\n\n\n\n\n\n\n\n\n\n\n\nCreating posts\n\n\n\n\n\n\nweek 0\n\n\nexample\n\n\n\n\n\n\n\n\n\nJan 21, 2024\n\n\nJessica Xiao\n\n\n\n\n\n\n\n\n\n\n\n\nPost With Code\n\n\n\n\n\n\nnews\n\n\ncode\n\n\nanalysis\n\n\n\n\n\n\n\n\n\nJan 16, 2024\n\n\nHarlow Malloc\n\n\n\n\n\n\n\n\n\n\n\n\nWelcome To My Blog\n\n\n\n\n\n\nnews\n\n\n\n\n\n\n\n\n\nJan 13, 2024\n\n\nTristan O’Malley\n\n\n\n\n\n\nNo matching items"
  }
]