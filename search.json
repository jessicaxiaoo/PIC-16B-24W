[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "posts/hw1/hw1.html",
    "href": "posts/hw1/hw1.html",
    "title": "HW1",
    "section": "",
    "text": "First, we will create a database with three tables: temperatures, stations, and countries. Lets import the necessary libraries.\nimport sqlite3\nimport pandas as pd\nimport numpy as np\nNow, we will read the temperatures data from a .csv file. Because this file is large, we read it into the database in chunks of 100000 rows. We will use the prepare_df function to clean up the data chunks as we read it in.\nconn = sqlite3.connect(\"hw1.db\") #open database connection\n\ntemps_iter = pd.read_csv(\"temps.csv\", chunksize = 100000)\ndef prepare_df(df):\n    df = df.set_index(keys=[\"ID\", \"Year\"])\n    df = df.stack()\n    df = df.reset_index()\n    df = df.rename(columns = {\"level_2\"  : \"Month\" , 0 : \"Temp\"})\n    df[\"Month\"] = df[\"Month\"].str[5:].astype(int)\n    df[\"Temp\"]  = df[\"Temp\"] / 100\n    return(df)\nfor temps in temps_iter:\n    temps = prepare_df(temps)\n    temps.to_sql(\"temperatures\", conn, if_exists = \"append\", index = False)\ntemps.head()\nLet’s read the data for countries and stations next.\ncountries = pd.read_csv('country-names.csv')\ncountries = countries.rename(columns= {\"FIPS 10-4\": \"FIPS_10-4\", \"ISO 3166\": \"ISO_3166\"})\ncountries.head()\nurl = \"https://raw.githubusercontent.com/PhilChodrow/PIC16B/master/datasets/noaa-ghcn/station-metadata.csv\"\nstations = pd.read_csv(url)\nstations[\"FIPS_10-4\"] = stations[\"ID\"].str[0:2]\nstations.head()\ncountries.to_sql(\"countries\", conn, if_exists=\"replace\", index=False)\nstations.to_sql(\"stations\", conn, if_exists=\"replace\", index=False)\n\n\n\nWe can write a function that uses a SQL command to extract a Pandas dataframe from our database. We use the LEFT JOIN keyword to merge the three tables, and the WHERE to specify the conditions (a country, two integers that give the earliest and latest years, and a specific month).\ndef query_climate_database(db_file, country, year_begin, year_end, month):\n    \n    conn = sqlite3.connect(db_file)\n\n    cmd = f\"\"\"\n    SELECT S.name, S.latitude, S.longitude, C.name, T.year, T.month, T.temp\n    FROM temperatures T\n    LEFT JOIN stations S ON T.id = S.id\n    LEFT JOIN countries C on SUBSTRING (T.id, 1, 2) = C.'FIPS 10-4'\n    WHERE C.name = ? AND T.year &gt;= {year_begin} AND T.year &lt;= {year_end} AND T.month = {month}\n    \n    \"\"\"\n    \n    df = pd.read_sql_query(cmd, conn, params=(country,))\n    conn.close()\n\n    df = df.rename(columns={'Name': 'Country'})\n\n    return df\n\nHere’s an example of using the function query_climate_database to query temperature data in India for August from 1980-2020.\n```python\nquery_climate_database(db_file = \"hw1.db\",\n                       country = \"India\", \n                       year_begin = 1980, \n                       year_end = 2020,\n                       month = 1)\n\n\n\noutput\n\n\n\n\n\n\n\nThis visualization answers the question: How does the average yearly change in temperature vary within a given country?\nWe will first import the packages necessary to achieve this. sklearn is used for linear regression, datetime converts numbers to their corresponding month names, and plotly is used to create the interactive visualizations.\nfrom sklearn.linear_model import LinearRegression\nimport datetime\nfrom plotly import express as px\nNow, we can define a function to perform a linear regression of the temperature on the year, and return the coefficients.\ndef coef(data_group):\n    '''\n    Inputs: dataframe\n    Returns: slope of linear model, representing the average yearly change in temperature\n    '''\n    x = data_group[[\"Year\"]]\n    y = data_group[\"Temp\"]\n    LR = LinearRegression()\n    LR.fit(x, y)\n    return LR.coef_[0]\nThe function temperature_coefficient_plot queries the specified data and produces a geographic scatterplot. The location of each point is the location of the station and the color is based on the estimate of yearly change in temperature at the station in the given time interval.\ndef temperature_coefficient_plot(country, year_begin, year_end, month, min_obs, **kwargs):\n    '''\n    Inputs: a country, a bounded time interval, a month, minimum data points to be considered, and optional\n    plotting arguments\n    Returns: a geographic plot indicating the changes in temperature over time\n    '''\n    #obtain and clean the data\n    df = query_climate_database(db_file = \"hw1.db\", country = country, year_begin = year_begin, year_end = year_end, month = month) #read in the data using previously defined function\n    counts = df.groupby([\"NAME\", \"Month\"])[\"Year\"].transform(len)\n    df = df[counts &gt;= min_obs]\n    coefs = df.groupby([\"NAME\", \"Month\", \"LATITUDE\", \"LONGITUDE\"]).apply(coef) #find the estimated yearly change in temperature for each station\n    coefs = coefs.round(3) # round data to 3 decimal places\n    coefs = coefs.reset_index()\n    coefs = coefs.rename(columns = {0 : \"Estimated Yearly Change (C)\"})\n\n    #create the plot\n    title = \"Estimates of Yearly Increase in Temperature in {a} for stations in {b}, years {c} - {d}\"\\\n    .format(a=datetime.date(2021, month, 1).strftime('%B'), b=country, c=year_begin, d=year_end)\n    fig = px.scatter_mapbox(coefs,\n                            lat = \"LATITUDE\",\n                            lon = \"LONGITUDE\",\n                            hover_name = \"NAME\",\n                            color = \"Estimated Yearly Change (C)\",\n                            title = title,\n                            **kwargs)\n    return fig\nHere is an example of using the temperature_coefficient_plot function to visualize the estimated change in temperature across stations in India in January from 1980 to 2020.\ncolor_map = px.colors.diverging.RdGy_r \n\nfig = temperature_coefficient_plot(country = \"India\", year_begin = 1980, year_end = 2020, month = 1, \n                                   min_obs = 10,\n                                   zoom = 2,\n                                   mapbox_style=\"carto-positron\",\n                                   color_continuous_scale=color_map)\nfig.show()\n\n\n\noutput\n\n\n\n\n\nThe visualization I chose answers the question: How is the mean temperature per year changing in comparison to the overall mean temperature?\nThe function diff_from_mean_temp function takes in the same arguments as the query_climate_database: country, year_begin, year_end, and month. With the returned dataframe, it takes the mean temperature over the entire time period and then finds the difference between the mean temperature of each year and the overall mean temperature.\ndef diff_from_mean_temp(country, year_begin, year_end, month, **kwargs):\n    '''\n    Input: a country, a bounded time interval, and a month\n    Returns: a barplot comparing the yearly temperature to the average temperature over the interval\n    '''\n    df = query_climate_database(\"hw1.db\", country, year_begin, year_end, month) \n    mean = np.mean(df[\"Temp\"]) #overall mean temperature of the time interval\n    df = df.groupby([\"Year\"])[\"Temp\"].aggregate(np.mean) #find mean temperature per year\n    df = df.reset_index()\n    df[\"Difference (C)\"] = df[\"Temp\"] - mean #compare mean temperature of year to mean temperature over entire time interval\n    df= df.round(3) #round to 3 decimal places\n    df[\"col\"] = np.where(df[\"Difference (C)\"]&gt;=0, 'red', 'blue')\n\n    #create the plot\n    title = \"Difference in Mean Temperature in {a} for stations in {b} from {c} to {d}\"\\\n    .format(a=datetime.date(2021, month, 1).strftime('%B'), b=country, c=year_begin, d=year_end)\n    fig = px.bar(df, x = \"Year\", y = \"Difference (C)\",\n                hover_data = [\"Year\", \"Difference (C)\"], title = title, color = \"col\", **kwargs)\n    fig.update_layout(showlegend=False) \n    return fig\nHere is an example of using the diff_from_mean_temp function to visualize the difference in mean temperature in China in March from 1980 to 2020.\nfig = diff_from_mean_temp(\"China\", 1980, 2020, 3)\nfig.show()\n Here, the positive red bars indicate that the temperature readings that year were above the mean, and negative blue bars indicate that temperature readings that year were below the mean.\n\n\n\nThe visualization I chose answers the question: How is does temperature vary within regions of a country in a given year?\nThe function query_country_year extracts the relevant data, and the output is passed to year_diff to calculate the difference between the average temperature in the warmest month and the coldest month, at the station level.\ndef query_country_year(db_file, country, year):\n    '''\n    Returns: a dataframe of all temperatures in a country in a single year\n    '''\n    conn = sqlite3.connect(db_file)\n    #cursor = conn.cursor()\n    cmd = f\"\"\"\n    SELECT S.name, S.latitude, S.longitude, C.name, T.year, T.month, T.temp\n    FROM temperatures T\n    LEFT JOIN stations S ON T.id = S.id\n    LEFT JOIN countries C ON C.'FIPS_10-4' = S.'FIPS_10-4'\n    WHERE T.year = {year} AND C.Name = '{country}'\n    \"\"\"\n    \n    df = pd.read_sql_query(cmd, conn)\n    return df\ndef year_diff(df):\n    '''\n    Computes temperature difference between warmest and coldest month\n    '''\n    df_group = df.groupby([\"NAME\"])\n    obs_filter = df_group.count()[\"Name\"]&gt;=12\n    temp_diff = (df_group.max()[['Temp']] - df_group.min()[['Temp']])[obs_filter]\n    coords = df.groupby([\"NAME\"]).first()[[\"LATITUDE\",\"LONGITUDE\"]][obs_filter]\n    x = pd.merge(temp_diff,coords,on='NAME')\n    x = x.rename(columns={'Temp':\"Temperature difference\"})\n    x = x.reset_index()\n    return x\nThe function seasonal_difference_plot takes in a country and a year, and creates a scatterplot of the difference in temperature between the warmest and coolest month of that year.\ndef seasonal_difference_plot(country, year,**kwargs):\n    x = year_diff(query_country_year(\"hw1.db\", country, year))\n    title = f\"Difference in temperature between warmest and coolest month in {year} for stations in {country}\"\n    fig = px.scatter_mapbox(x,\n                            lat = \"LATITUDE\",\n                            lon = \"LONGITUDE\",\n                            hover_name = \"NAME\",\n                            color = \"Temperature difference\",\n                            hover_data={\n                                \"LATITUDE\":':.3f',\n                                \"LONGITUDE\":':.3f',\n                                \"Temperature difference\":':.3f'\n                            },\n                            title = title,\n                            color_continuous_scale=color_map,\n                            **kwargs)\n\n    return fig\nAn example can be seen with Mexico in the year 2020.\nfig = seasonal_difference_plot('Mexico', 2020,\n                               mapbox_style=\"carto-positron\",\n                               zoom=1)\npio.write_image(fig, \"seasonal-diff-barplot.png\")\nfig.show()\n\n\n\noutput\n\n\n\n\n\nThe last visualization I chose answers the question: How does temperature vary across months in a given country? The function query_year_range extracts the relevant data and creates a pandas dataframe from our database. We use the LEFT JOIN keyword to merge the three tables, and the WHERE to specify the conditions (a country and two integers that give the earliest and latest years).\ndef query_country_year_range(db_file, country, year_begin, year_end):\n    '''\n    returns dataframe of all temperatures in a country in a single year.\n    '''\n    conn = sqlite3.connect(db_file)\n    \n    cmd = f\"\"\"\n    SELECT S.name, S.latitude, S.longitude, C.name, T.year, T.month, T.temp\n    FROM temperatures T\n    LEFT JOIN stations S ON T.id = S.id\n    LEFT JOIN countries C ON C.'FIPS 10-4' = S.'FIPS 10-4'\n    WHERE C.name = ? AND T.year &gt;= {year_begin} AND T.year &lt;= {year_end}\n    \"\"\"\n    \n    df = pd.read_sql_query(cmd, conn, params=(country,))\n    return df\nThe function facet_hist takes in a country and two integers for years, and creates a faceted histogram of the temperatures for each month.\ndef facet_hist(country, year_begin, year_end, **kwargs):\n    '''\n    Inputs:\n    '''\n    df = query_country_year_range(\"hw1.db\", country, year_begin, year_end) \n    df.sort_values([\"Year\", \"Month\", \"Temp\"], inplace = True)\n    \n    title = f\"Distribution of Monthly Temperature in {country} between {year_begin} and {year_end}\"\n    fig = px.histogram(df,\n                       x = \"Temp\", \n                       color = \"Year\",\n                       opacity = 0.8, \n                       nbins = 20,\n                       barmode='group',\n                       histnorm = 'percent',\n                       width = 900,\n                       height = 1500,\n                       facet_col = 'Month',\n                       facet_col_wrap = 3, \n                       title = title,\n                        **kwargs)\n    return fig\nAn example can be seen with Canada in the 2018-2020.\nfig = facet_hist(\"Canada\", 2018, 2020)\nfig.show()\n\n\n\noutput"
  },
  {
    "objectID": "posts/hw1/hw1.html#create-a-database",
    "href": "posts/hw1/hw1.html#create-a-database",
    "title": "HW1",
    "section": "",
    "text": "First, we will create a database with three tables: temperatures, stations, and countries. Lets import the necessary libraries.\nimport sqlite3\nimport pandas as pd\nimport numpy as np\nNow, we will read the temperatures data from a .csv file. Because this file is large, we read it into the database in chunks of 100000 rows. We will use the prepare_df function to clean up the data chunks as we read it in.\nconn = sqlite3.connect(\"hw1.db\") #open database connection\n\ntemps_iter = pd.read_csv(\"temps.csv\", chunksize = 100000)\ndef prepare_df(df):\n    df = df.set_index(keys=[\"ID\", \"Year\"])\n    df = df.stack()\n    df = df.reset_index()\n    df = df.rename(columns = {\"level_2\"  : \"Month\" , 0 : \"Temp\"})\n    df[\"Month\"] = df[\"Month\"].str[5:].astype(int)\n    df[\"Temp\"]  = df[\"Temp\"] / 100\n    return(df)\nfor temps in temps_iter:\n    temps = prepare_df(temps)\n    temps.to_sql(\"temperatures\", conn, if_exists = \"append\", index = False)\ntemps.head()\nLet’s read the data for countries and stations next.\ncountries = pd.read_csv('country-names.csv')\ncountries = countries.rename(columns= {\"FIPS 10-4\": \"FIPS_10-4\", \"ISO 3166\": \"ISO_3166\"})\ncountries.head()\nurl = \"https://raw.githubusercontent.com/PhilChodrow/PIC16B/master/datasets/noaa-ghcn/station-metadata.csv\"\nstations = pd.read_csv(url)\nstations[\"FIPS_10-4\"] = stations[\"ID\"].str[0:2]\nstations.head()\ncountries.to_sql(\"countries\", conn, if_exists=\"replace\", index=False)\nstations.to_sql(\"stations\", conn, if_exists=\"replace\", index=False)"
  },
  {
    "objectID": "posts/hw1/hw1.html#query-the-database",
    "href": "posts/hw1/hw1.html#query-the-database",
    "title": "HW1",
    "section": "",
    "text": "We can write a function that uses a SQL command to extract a Pandas dataframe from our database. We use the LEFT JOIN keyword to merge the three tables, and the WHERE to specify the conditions (a country, two integers that give the earliest and latest years, and a specific month).\ndef query_climate_database(db_file, country, year_begin, year_end, month):\n    \n    conn = sqlite3.connect(db_file)\n\n    cmd = f\"\"\"\n    SELECT S.name, S.latitude, S.longitude, C.name, T.year, T.month, T.temp\n    FROM temperatures T\n    LEFT JOIN stations S ON T.id = S.id\n    LEFT JOIN countries C on SUBSTRING (T.id, 1, 2) = C.'FIPS 10-4'\n    WHERE C.name = ? AND T.year &gt;= {year_begin} AND T.year &lt;= {year_end} AND T.month = {month}\n    \n    \"\"\"\n    \n    df = pd.read_sql_query(cmd, conn, params=(country,))\n    conn.close()\n\n    df = df.rename(columns={'Name': 'Country'})\n\n    return df\n\nHere’s an example of using the function query_climate_database to query temperature data in India for August from 1980-2020.\n```python\nquery_climate_database(db_file = \"hw1.db\",\n                       country = \"India\", \n                       year_begin = 1980, \n                       year_end = 2020,\n                       month = 1)\n\n\n\noutput"
  },
  {
    "objectID": "posts/hw1/hw1.html#creating-interactive-visualizations",
    "href": "posts/hw1/hw1.html#creating-interactive-visualizations",
    "title": "HW1",
    "section": "",
    "text": "This visualization answers the question: How does the average yearly change in temperature vary within a given country?\nWe will first import the packages necessary to achieve this. sklearn is used for linear regression, datetime converts numbers to their corresponding month names, and plotly is used to create the interactive visualizations.\nfrom sklearn.linear_model import LinearRegression\nimport datetime\nfrom plotly import express as px\nNow, we can define a function to perform a linear regression of the temperature on the year, and return the coefficients.\ndef coef(data_group):\n    '''\n    Inputs: dataframe\n    Returns: slope of linear model, representing the average yearly change in temperature\n    '''\n    x = data_group[[\"Year\"]]\n    y = data_group[\"Temp\"]\n    LR = LinearRegression()\n    LR.fit(x, y)\n    return LR.coef_[0]\nThe function temperature_coefficient_plot queries the specified data and produces a geographic scatterplot. The location of each point is the location of the station and the color is based on the estimate of yearly change in temperature at the station in the given time interval.\ndef temperature_coefficient_plot(country, year_begin, year_end, month, min_obs, **kwargs):\n    '''\n    Inputs: a country, a bounded time interval, a month, minimum data points to be considered, and optional\n    plotting arguments\n    Returns: a geographic plot indicating the changes in temperature over time\n    '''\n    #obtain and clean the data\n    df = query_climate_database(db_file = \"hw1.db\", country = country, year_begin = year_begin, year_end = year_end, month = month) #read in the data using previously defined function\n    counts = df.groupby([\"NAME\", \"Month\"])[\"Year\"].transform(len)\n    df = df[counts &gt;= min_obs]\n    coefs = df.groupby([\"NAME\", \"Month\", \"LATITUDE\", \"LONGITUDE\"]).apply(coef) #find the estimated yearly change in temperature for each station\n    coefs = coefs.round(3) # round data to 3 decimal places\n    coefs = coefs.reset_index()\n    coefs = coefs.rename(columns = {0 : \"Estimated Yearly Change (C)\"})\n\n    #create the plot\n    title = \"Estimates of Yearly Increase in Temperature in {a} for stations in {b}, years {c} - {d}\"\\\n    .format(a=datetime.date(2021, month, 1).strftime('%B'), b=country, c=year_begin, d=year_end)\n    fig = px.scatter_mapbox(coefs,\n                            lat = \"LATITUDE\",\n                            lon = \"LONGITUDE\",\n                            hover_name = \"NAME\",\n                            color = \"Estimated Yearly Change (C)\",\n                            title = title,\n                            **kwargs)\n    return fig\nHere is an example of using the temperature_coefficient_plot function to visualize the estimated change in temperature across stations in India in January from 1980 to 2020.\ncolor_map = px.colors.diverging.RdGy_r \n\nfig = temperature_coefficient_plot(country = \"India\", year_begin = 1980, year_end = 2020, month = 1, \n                                   min_obs = 10,\n                                   zoom = 2,\n                                   mapbox_style=\"carto-positron\",\n                                   color_continuous_scale=color_map)\nfig.show()\n\n\n\noutput\n\n\n\n\n\nThe visualization I chose answers the question: How is the mean temperature per year changing in comparison to the overall mean temperature?\nThe function diff_from_mean_temp function takes in the same arguments as the query_climate_database: country, year_begin, year_end, and month. With the returned dataframe, it takes the mean temperature over the entire time period and then finds the difference between the mean temperature of each year and the overall mean temperature.\ndef diff_from_mean_temp(country, year_begin, year_end, month, **kwargs):\n    '''\n    Input: a country, a bounded time interval, and a month\n    Returns: a barplot comparing the yearly temperature to the average temperature over the interval\n    '''\n    df = query_climate_database(\"hw1.db\", country, year_begin, year_end, month) \n    mean = np.mean(df[\"Temp\"]) #overall mean temperature of the time interval\n    df = df.groupby([\"Year\"])[\"Temp\"].aggregate(np.mean) #find mean temperature per year\n    df = df.reset_index()\n    df[\"Difference (C)\"] = df[\"Temp\"] - mean #compare mean temperature of year to mean temperature over entire time interval\n    df= df.round(3) #round to 3 decimal places\n    df[\"col\"] = np.where(df[\"Difference (C)\"]&gt;=0, 'red', 'blue')\n\n    #create the plot\n    title = \"Difference in Mean Temperature in {a} for stations in {b} from {c} to {d}\"\\\n    .format(a=datetime.date(2021, month, 1).strftime('%B'), b=country, c=year_begin, d=year_end)\n    fig = px.bar(df, x = \"Year\", y = \"Difference (C)\",\n                hover_data = [\"Year\", \"Difference (C)\"], title = title, color = \"col\", **kwargs)\n    fig.update_layout(showlegend=False) \n    return fig\nHere is an example of using the diff_from_mean_temp function to visualize the difference in mean temperature in China in March from 1980 to 2020.\nfig = diff_from_mean_temp(\"China\", 1980, 2020, 3)\nfig.show()\n Here, the positive red bars indicate that the temperature readings that year were above the mean, and negative blue bars indicate that temperature readings that year were below the mean.\n\n\n\nThe visualization I chose answers the question: How is does temperature vary within regions of a country in a given year?\nThe function query_country_year extracts the relevant data, and the output is passed to year_diff to calculate the difference between the average temperature in the warmest month and the coldest month, at the station level.\ndef query_country_year(db_file, country, year):\n    '''\n    Returns: a dataframe of all temperatures in a country in a single year\n    '''\n    conn = sqlite3.connect(db_file)\n    #cursor = conn.cursor()\n    cmd = f\"\"\"\n    SELECT S.name, S.latitude, S.longitude, C.name, T.year, T.month, T.temp\n    FROM temperatures T\n    LEFT JOIN stations S ON T.id = S.id\n    LEFT JOIN countries C ON C.'FIPS_10-4' = S.'FIPS_10-4'\n    WHERE T.year = {year} AND C.Name = '{country}'\n    \"\"\"\n    \n    df = pd.read_sql_query(cmd, conn)\n    return df\ndef year_diff(df):\n    '''\n    Computes temperature difference between warmest and coldest month\n    '''\n    df_group = df.groupby([\"NAME\"])\n    obs_filter = df_group.count()[\"Name\"]&gt;=12\n    temp_diff = (df_group.max()[['Temp']] - df_group.min()[['Temp']])[obs_filter]\n    coords = df.groupby([\"NAME\"]).first()[[\"LATITUDE\",\"LONGITUDE\"]][obs_filter]\n    x = pd.merge(temp_diff,coords,on='NAME')\n    x = x.rename(columns={'Temp':\"Temperature difference\"})\n    x = x.reset_index()\n    return x\nThe function seasonal_difference_plot takes in a country and a year, and creates a scatterplot of the difference in temperature between the warmest and coolest month of that year.\ndef seasonal_difference_plot(country, year,**kwargs):\n    x = year_diff(query_country_year(\"hw1.db\", country, year))\n    title = f\"Difference in temperature between warmest and coolest month in {year} for stations in {country}\"\n    fig = px.scatter_mapbox(x,\n                            lat = \"LATITUDE\",\n                            lon = \"LONGITUDE\",\n                            hover_name = \"NAME\",\n                            color = \"Temperature difference\",\n                            hover_data={\n                                \"LATITUDE\":':.3f',\n                                \"LONGITUDE\":':.3f',\n                                \"Temperature difference\":':.3f'\n                            },\n                            title = title,\n                            color_continuous_scale=color_map,\n                            **kwargs)\n\n    return fig\nAn example can be seen with Mexico in the year 2020.\nfig = seasonal_difference_plot('Mexico', 2020,\n                               mapbox_style=\"carto-positron\",\n                               zoom=1)\npio.write_image(fig, \"seasonal-diff-barplot.png\")\nfig.show()\n\n\n\noutput\n\n\n\n\n\nThe last visualization I chose answers the question: How does temperature vary across months in a given country? The function query_year_range extracts the relevant data and creates a pandas dataframe from our database. We use the LEFT JOIN keyword to merge the three tables, and the WHERE to specify the conditions (a country and two integers that give the earliest and latest years).\ndef query_country_year_range(db_file, country, year_begin, year_end):\n    '''\n    returns dataframe of all temperatures in a country in a single year.\n    '''\n    conn = sqlite3.connect(db_file)\n    \n    cmd = f\"\"\"\n    SELECT S.name, S.latitude, S.longitude, C.name, T.year, T.month, T.temp\n    FROM temperatures T\n    LEFT JOIN stations S ON T.id = S.id\n    LEFT JOIN countries C ON C.'FIPS 10-4' = S.'FIPS 10-4'\n    WHERE C.name = ? AND T.year &gt;= {year_begin} AND T.year &lt;= {year_end}\n    \"\"\"\n    \n    df = pd.read_sql_query(cmd, conn, params=(country,))\n    return df\nThe function facet_hist takes in a country and two integers for years, and creates a faceted histogram of the temperatures for each month.\ndef facet_hist(country, year_begin, year_end, **kwargs):\n    '''\n    Inputs:\n    '''\n    df = query_country_year_range(\"hw1.db\", country, year_begin, year_end) \n    df.sort_values([\"Year\", \"Month\", \"Temp\"], inplace = True)\n    \n    title = f\"Distribution of Monthly Temperature in {country} between {year_begin} and {year_end}\"\n    fig = px.histogram(df,\n                       x = \"Temp\", \n                       color = \"Year\",\n                       opacity = 0.8, \n                       nbins = 20,\n                       barmode='group',\n                       histnorm = 'percent',\n                       width = 900,\n                       height = 1500,\n                       facet_col = 'Month',\n                       facet_col_wrap = 3, \n                       title = title,\n                        **kwargs)\n    return fig\nAn example can be seen with Canada in the 2018-2020.\nfig = facet_hist(\"Canada\", 2018, 2020)\nfig.show()\n\n\n\noutput"
  },
  {
    "objectID": "posts/hw3/mnist-model/mnist-prep.html",
    "href": "posts/hw3/mnist-model/mnist-prep.html",
    "title": "Training an MNIST Classification Model",
    "section": "",
    "text": "In this short notebook, we’ll train a logistic regression model for classifying handwritten digits, with the aim of incorporating this model into a webapp.\nFor a more thorough discussion training and assessing the model, please consult these lecture notes or this video from PIC16A.\n\nimport pandas as pd\nfrom matplotlib import pyplot as plt\nfrom sklearn.datasets import load_digits\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.linear_model import LogisticRegression\nimport numpy as np\n\nFirst we’ll acquire the data and take a look:\n\ndigits = load_digits()\ndigits.keys()\n\ndict_keys(['data', 'target', 'frame', 'feature_names', 'target_names', 'images', 'DESCR'])\n\n\nHere’s an individual digit. Note that we need to reshape the data into a square shape to plot it.\n\nfig, ax = plt.subplots(1)\ni = 200\n\nax.imshow(digits['data'][i].reshape(8, 8), cmap = plt.cm.binary)\nax.set(title = \"True digit: \" + str(digits['target'][i]))\n\n\n\n\n\n\n\n\nNow we’ll split the data into training and test sets.\n\nX_train, X_test, y_train, y_test = train_test_split(digits.data, digits.target)\n\nNext we’ll create a logistic regression model and fit it to the training data.\n\nm = LogisticRegression(random_state = 0, solver = \"liblinear\")\n\n\nm.fit(X_train, y_train)\n\nLogisticRegression(random_state=0, solver='liblinear')In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.LogisticRegressionLogisticRegression(random_state=0, solver='liblinear')\n\n\nHow well does our model predict unseen images in the test set?\n\nm.score(X_test, y_test)\n\n0.9533333333333334\n\n\n\n\nNow for the key step for today: we are going to pickle the model so that we can use it elsewhere. You can think of pickling is just a funny word for saving the model. We pickle the model by caling pickle.dump with an open file connection.\n\nimport pickle\nfilename = 'model.pkl'\npickle.dump(m, open(filename, 'wb'))\n\nOnce we’ve pickled the model, we can use it anywhere we want, by using pickle.load().\n\nM = pickle.load(open(filename, 'rb'))\n\n\nM.score(X_test, y_test)\n\n0.9533333333333334\n\n\n\n\n\nThe code below saves a few example digits for us to play with in our webapp.\n\nfor i in range(10):\n    j = np.random.randint(0, digits[\"data\"].shape[0])\n    np.savetxt(\"sample-data/\" + str(j) + \".txt\", digits['data'][j].reshape(8, 8))"
  },
  {
    "objectID": "posts/hw3/mnist-model/mnist-prep.html#pickling",
    "href": "posts/hw3/mnist-model/mnist-prep.html#pickling",
    "title": "Training an MNIST Classification Model",
    "section": "",
    "text": "Now for the key step for today: we are going to pickle the model so that we can use it elsewhere. You can think of pickling is just a funny word for saving the model. We pickle the model by caling pickle.dump with an open file connection.\n\nimport pickle\nfilename = 'model.pkl'\npickle.dump(m, open(filename, 'wb'))\n\nOnce we’ve pickled the model, we can use it anywhere we want, by using pickle.load().\n\nM = pickle.load(open(filename, 'rb'))\n\n\nM.score(X_test, y_test)\n\n0.9533333333333334"
  },
  {
    "objectID": "posts/hw3/mnist-model/mnist-prep.html#saving-example-digits",
    "href": "posts/hw3/mnist-model/mnist-prep.html#saving-example-digits",
    "title": "Training an MNIST Classification Model",
    "section": "",
    "text": "The code below saves a few example digits for us to play with in our webapp.\n\nfor i in range(10):\n    j = np.random.randint(0, digits[\"data\"].shape[0])\n    np.savetxt(\"sample-data/\" + str(j) + \".txt\", digits['data'][j].reshape(8, 8))"
  },
  {
    "objectID": "posts/bruin/index.html",
    "href": "posts/bruin/index.html",
    "title": "Creating posts",
    "section": "",
    "text": "HW0\nIn this blog post, we will be creating a data visualization on the Palmer Penguins dataset.\n\nImporting libraries and reading data\nFirst, let’s import the necessary libararies and read the data into python.\nimport pandas as pd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\nurl = \"https://raw.githubusercontent.com/pic16b-ucla/24W/main/datasets/palmer_penguins.csv\"\npenguins = pd.read_csv(url)\nAs seen in the code above, pandas is used to read the data. We will next use seaborn and matplotlib to create our plot.\n\n\nCreating the scatterplot\nNext, we will use the seaborn library to create our scatterplot. The scatterplot function takes the in the arguments data, x, y, and hue.\nsns.scatterplot(data=penguins, x=\"Culmen Length (mm)\", y=\"Body Mass (g)\", hue=\"Species\")\n From this plot, we can see that there is a postive correlation between culmen length and body mass. Furthermore, we can see the differences between the 3 species of penguins.\nTo improve our visualization, let’s add a title and move the legend to the side of the plot.\nplt.legend(bbox_to_anchor=(1.05, 1),loc=2)\nplt.title(\"Scatter Plot of Culmen Length vs. Body Mass\")\n\n\n\noutput"
  },
  {
    "objectID": "posts/post-with-code/index.html",
    "href": "posts/post-with-code/index.html",
    "title": "Post With Code",
    "section": "",
    "text": "This is a post with executable code."
  },
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "This is the first post in a Quarto blog. Welcome!\n\nSince this post doesn’t specify an explicit image, the first image in the post will be used in the listing page of posts."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "myblog",
    "section": "",
    "text": "Training an MNIST Classification Model\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHW1\n\n\n\n\n\n\nweek 3\n\n\nexample\n\n\n\n\n\n\n\n\n\nJan 29, 2024\n\n\nJessica Xiao\n\n\n\n\n\n\n\n\n\n\n\n\nCreating posts\n\n\n\n\n\n\nweek 0\n\n\nexample\n\n\n\n\n\n\n\n\n\nJan 21, 2024\n\n\nJessica Xiao\n\n\n\n\n\n\n\n\n\n\n\n\nPost With Code\n\n\n\n\n\n\nnews\n\n\ncode\n\n\nanalysis\n\n\n\n\n\n\n\n\n\nJan 16, 2024\n\n\nHarlow Malloc\n\n\n\n\n\n\n\n\n\n\n\n\nWelcome To My Blog\n\n\n\n\n\n\nnews\n\n\n\n\n\n\n\n\n\nJan 13, 2024\n\n\nTristan O’Malley\n\n\n\n\n\n\nNo matching items"
  }
]